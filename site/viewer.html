<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Interaktiver 3D-Viewer für den MESH-S-Knoten.">
  <title>3D-Viewer</title>
  <link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="themes.css">
</head>
<body>
  <main class="viewer-page">
    <header class="viewer-header">
      <div class="viewer-header-main">
        <a class="btn btn-outline" href="/" data-variant-back-link>← Zurück</a>
        <div class="viewer-header-text">
          <h1>3D-Viewer</h1>
          <p class="viewer-hint">Ziehen zum Drehen, Scrollen/Pinch zum Zoomen.</p>
        </div>
      </div>
      <div class="viewer-header-actions">
        <button class="btn btn-outline" id="resetView" type="button">Ansicht zurücksetzen</button>
      </div>
    </header>
    <div class="viewer-variant">
      <span class="viewer-variant__brand">MESH-S</span>
      <span class="viewer-variant__suffix" data-variant-suffix></span>
    </div>
    <div class="variant-switch" role="group" aria-label="Variantenauswahl">
          <button class="variant-option" type="button" data-variant="s">S</button>
          <button class="variant-option" type="button" data-variant="m">M</button>
          <button class="variant-option" type="button" data-variant="l">L</button>
          <button class="variant-option" type="button" data-variant="xl">XL</button>
      </div>

    <section class="viewer-stage">
      <div id="viewerCanvasWrap" aria-live="polite"></div>
      <div id="viewerOverlay" class="viewer-overlay">
        <div class="viewer-overlay-card">
          <div class="viewer-loading" id="viewerLoading">3D-Modell wird geladen…</div>
          <div class="viewer-progress" id="viewerProgress">0%</div>
          <div class="viewer-error is-hidden" id="viewerError">3D-Modell ist noch nicht verfügbar. Bitte assets/variants/s/models/mesh-s.glb hinzufügen.</div>
          <p style="margin-top: 12px; font-size: 14px; opacity: 0.8;">Versuche, den Browser-Cache zu leeren und die Seite neu zu laden.</p>
          <a class="btn btn-outline is-hidden" id="viewerErrorBack" href="/" data-variant-back-link>← Zurück</a>
        </div>
      </div>
    </section>
  </main>

  <script src="variants.js?v=20251226-1"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/addons/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const allowedVariants = new Set(["s", "m", "l", "xl"]);
    const fallbackVariant = "s";

    const canvasWrap = document.getElementById("viewerCanvasWrap");
    const overlay = document.getElementById("viewerOverlay");
    const loadingEl = document.getElementById("viewerLoading");
    const progressEl = document.getElementById("viewerProgress");
    const errorEl = document.getElementById("viewerError");
    const errorBack = document.getElementById("viewerErrorBack");
    const resetButton = document.getElementById("resetView");

    let renderer;
    let camera;
    let controls;
    let scene;
    let currentModel;

    const parseVariantId = () => {
      const params = new URLSearchParams(window.location.search);
      const raw = (params.get("v") || fallbackVariant).toLowerCase();
      return allowedVariants.has(raw) ? raw : fallbackVariant;
    };

    const updateBackLinks = (variantId) => {
      document.querySelectorAll("[data-variant-back-link]").forEach((link) => {
        const href = link.getAttribute("href") || "/";
        const url = new URL(href, window.location.origin);
        url.searchParams.set("v", variantId);
        link.setAttribute("href", url.pathname + url.search + url.hash);
      });
    };

    const updateVariantButtons = (variantId) => {
      document.querySelectorAll(".variant-option").forEach((btn) => {
        const isActive = btn.dataset.variant === variantId;
        btn.classList.toggle("is-active", isActive);
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
      });
    };

    const resolveVariantSuffix = (variant) => {
      if (!variant || !variant.labels) return "";
      if (variant.labels.badge) {
        return ` / ${variant.labels.badge}`;
      }
      if (variant.labels.full) {
        const trimmed = variant.labels.full.replace(/^MESH-S/i, "").trim();
        if (!trimmed) return "";
        return trimmed.startsWith("/") ? ` ${trimmed}` : ` / ${trimmed}`;
      }
      return "";
    };

    const updateVariantSuffix = (suffix) => {
      const el = document.querySelector("[data-variant-suffix]");
      if (!el) return;
      el.textContent = suffix || "";
    };

    const setOverlayVisible = (visible) => {
      overlay.classList.toggle("is-hidden", !visible);
    };

    const showError = () => {
      setOverlayVisible(true);
      errorEl.classList.remove("is-hidden");
      errorBack.classList.remove("is-hidden");
      loadingEl.classList.add("is-hidden");
      progressEl.classList.add("is-hidden");
    };

    const initScene = () => {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0d12);

      camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.set(2.5, 1.8, 2.5);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(1, 1);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      canvasWrap.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.dampingFactor = 0.08;

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x1d1f2a, 1.0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(4, 6, 3);
      scene.add(dirLight);

      const animate = () => {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };
      animate();
    };

    const resizeRenderer = () => {
      const { clientWidth, clientHeight } = canvasWrap;
      if (!clientWidth || !clientHeight) return;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    };

    const fitCameraToObject = (object) => {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      object.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = (camera.fov * Math.PI) / 180;
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.4;

      camera.position.set(cameraZ, cameraZ * 0.35, cameraZ);
      camera.near = Math.max(maxDim / 100, 0.01);
      camera.far = maxDim * 20;
      camera.updateProjectionMatrix();

      controls.target.set(0, 0, 0);
      controls.minDistance = cameraZ * 0.25;
      controls.maxDistance = cameraZ * 4.5;
      controls.update();
      controls.saveState();
    };

    const loadModel = (modelUrl) => {
      const loader = new GLTFLoader();
      loader.load(
        modelUrl,
        (gltf) => {
          const model = gltf.scene;
          if (currentModel) {
            scene.remove(currentModel);
          }
          currentModel = model;
          scene.add(model);
          fitCameraToObject(model);
          resizeRenderer();
          setOverlayVisible(false);
        },
        (xhr) => {
          if (xhr.total) {
            const percent = Math.round((xhr.loaded / xhr.total) * 100);
            progressEl.textContent = `${percent}%`;
          } else {
            progressEl.textContent = `${Math.round(xhr.loaded / 1024)} KB…`;
          }
        },
        () => {
          showError();
        }
      );
    };

    const fetchVariant = async (variantId) => {
      try {
        const res = await fetch(`assets/variants/${variantId}/variant.json`, { cache: "no-store" });
        if (!res.ok) {
          throw new Error("Variant not found");
        }
        const data = await res.json();
        return { id: variantId, ...data };
      } catch (error) {
        return null;
      }
    };

    const loadVariantModel = async (variantId) => {
      let variant = await fetchVariant(variantId);
      if (
        (!variant || !variant.assets || !variant.assets.viewerModel) &&
        variantId !== fallbackVariant
      ) {
        variant = await fetchVariant(fallbackVariant);
      }

      if (!variant || !variant.assets || !variant.assets.viewerModel) {
        updateVariantSuffix(` / ${fallbackVariant.toUpperCase()}`);
        showError();
        return;
      }

      updateBackLinks(variant.id || fallbackVariant);
      updateVariantButtons(variant.id || fallbackVariant);
      updateVariantSuffix(resolveVariantSuffix(variant));
      setOverlayVisible(true);
      loadingEl.classList.remove("is-hidden");
      progressEl.classList.remove("is-hidden");
      errorEl.classList.add("is-hidden");
      errorBack.classList.add("is-hidden");
      loadModel(variant.assets.viewerModel);
    };

    initScene();
    resizeRenderer();
    const initialVariant = parseVariantId();
    updateBackLinks(initialVariant);
    updateVariantButtons(initialVariant);
    updateVariantSuffix(` / ${fallbackVariant.toUpperCase()}`);
    loadVariantModel(initialVariant);

    window.addEventListener("resize", resizeRenderer);

    resetButton.addEventListener("click", () => {
      if (controls) {
        controls.reset();
      }
    });

    setOverlayVisible(true);

    document.querySelectorAll(".variant-option").forEach((btn) => {
      btn.addEventListener("click", () => {
        const next = btn.dataset.variant;
        if (!allowedVariants.has(next)) return;
        const url = new URL(window.location.href);
        url.searchParams.set("v", next);
        window.location.href = url.pathname + url.search + url.hash;
      });
    });
  </script>
  <script>
    (function () {
      if (window.__navMoreDismiss) return;
      window.__navMoreDismiss = true;

      const closeAll = () => {
        document.querySelectorAll('details.nav-more[open]').forEach((details) => {
          details.removeAttribute('open');
        });
      };

      document.addEventListener('click', (event) => {
        const openMenus = document.querySelectorAll('details.nav-more[open]');
        if (!openMenus.length) return;
        const target = event.target;
        if (target && target.closest && target.closest('details.nav-more')) return;
        openMenus.forEach((details) => {
          details.removeAttribute('open');
        });
      });

      document.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        closeAll();
      });
    })();
  </script>
</body>
</html>
