<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Interactive 3D viewer for the MESH-S node.">
  <title data-i18n="viewer.title">3D Viewer</title>
  <link rel="icon" href="assets/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="assets/apple-touch-icon.png">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <main class="viewer-page">
    <header class="viewer-header">
      <div class="viewer-header-main">
        <a class="btn btn-outline" href="/" data-i18n="viewer.back">← Back</a>
        <div class="viewer-header-text">
          <h1 data-i18n="viewer.title">3D Viewer</h1>
          <p class="viewer-hint" data-i18n="viewer.hint">Drag to rotate, scroll/pinch to zoom.</p>
        </div>
      </div>
      <div class="viewer-header-actions">
        <button class="btn btn-outline" id="resetView" type="button" data-i18n="viewer.reset">Reset view</button>
        <div class="lang-switch" role="group" data-i18n-aria="lang.aria">
          <button class="lang-option" type="button" data-lang="de">DE</button>
          <span class="lang-separator">|</span>
          <button class="lang-option" type="button" data-lang="en">EN</button>
        </div>
      </div>
    </header>

    <section class="viewer-stage">
      <div id="viewerCanvasWrap" aria-live="polite"></div>
      <div id="viewerOverlay" class="viewer-overlay">
        <div class="viewer-overlay-card">
          <div class="viewer-loading" id="viewerLoading" data-i18n="viewer.loading">Loading 3D model…</div>
          <div class="viewer-progress" id="viewerProgress">0%</div>
          <div class="viewer-error is-hidden" id="viewerError" data-i18n="viewer.error">Model not available yet.</div>
          <p style="margin-top: 12px; font-size: 14px; opacity: 0.8;" data-i18n="viewer.error-hint">Try clearing your browser cache and reloading the page.</p>
          <a class="btn btn-outline is-hidden" id="viewerErrorBack" href="/" data-i18n="viewer.back">← Back</a>
        </div>
      </div>
    </section>
  </main>

  <script src="i18n.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js",
        "three/addons/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const MODEL_URL = "assets/models/mesh-s.glb";

    const canvasWrap = document.getElementById("viewerCanvasWrap");
    const overlay = document.getElementById("viewerOverlay");
    const loadingEl = document.getElementById("viewerLoading");
    const progressEl = document.getElementById("viewerProgress");
    const errorEl = document.getElementById("viewerError");
    const errorBack = document.getElementById("viewerErrorBack");
    const resetButton = document.getElementById("resetView");

    let renderer;
    let camera;
    let controls;
    let scene;

    const setOverlayVisible = (visible) => {
      overlay.classList.toggle("is-hidden", !visible);
    };

    const showError = () => {
      setOverlayVisible(true);
      errorEl.classList.remove("is-hidden");
      errorBack.classList.remove("is-hidden");
      loadingEl.classList.add("is-hidden");
      progressEl.classList.add("is-hidden");
    };

    const initScene = () => {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0d12);

      camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.set(2.5, 1.8, 2.5);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(1, 1);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      canvasWrap.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.dampingFactor = 0.08;

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x1d1f2a, 1.0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(4, 6, 3);
      scene.add(dirLight);

      const animate = () => {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };
      animate();
    };

    const resizeRenderer = () => {
      const { clientWidth, clientHeight } = canvasWrap;
      if (!clientWidth || !clientHeight) return;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    };

    const fitCameraToObject = (object) => {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      object.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = (camera.fov * Math.PI) / 180;
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.4;

      camera.position.set(cameraZ, cameraZ * 0.35, cameraZ);
      camera.near = Math.max(maxDim / 100, 0.01);
      camera.far = maxDim * 20;
      camera.updateProjectionMatrix();

      controls.target.set(0, 0, 0);
      controls.minDistance = cameraZ * 0.25;
      controls.maxDistance = cameraZ * 4.5;
      controls.update();
      controls.saveState();
    };

    const loadModel = () => {
      const loader = new GLTFLoader();
      loader.load(
        MODEL_URL,
        (gltf) => {
          const model = gltf.scene;
          scene.add(model);
          fitCameraToObject(model);
          resizeRenderer();
          setOverlayVisible(false);
        },
        (xhr) => {
          if (xhr.total) {
            const percent = Math.round((xhr.loaded / xhr.total) * 100);
            progressEl.textContent = `${percent}%`;
          } else {
            progressEl.textContent = `${Math.round(xhr.loaded / 1024)} KB…`;
          }
        },
        () => {
          showError();
        }
      );
    };

    initScene();
    resizeRenderer();
    loadModel();

    window.addEventListener("resize", resizeRenderer);

    resetButton.addEventListener("click", () => {
      if (controls) {
        controls.reset();
      }
    });

    setOverlayVisible(true);
  </script>
</body>
</html>
